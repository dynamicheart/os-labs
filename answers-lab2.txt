# JOS LAB2文档
杨健邦 515030910223

文档的第一部分是阐述此次lab各个部分的设计(只陈序一部分相对复杂的函数的设计)，中间一部分是问题的解答，最后一个部分是讲challenge的实现。



## 第一部分 -- lab的设计思路

### Part 1

boot_alloc(): 在新页表创建好之前，先用这个函数来分配空间，只需将next_free加上一个分配空间即
可，但是要注意每次分配的空间都必须是页大小的整数倍。而且由于初始化的页表(entrypgdir.c中)
只映射了0 - 4MB的物理地址，因此在boot_alloc中还要检查是否内存耗尽，以免初始页表无法进行地址翻译。


page_init(): 创建空闲物理页链表。 有四个部分的物理页是已经被分配的，第一部分是0号页表，第二
部分是未创建好页表时运行kernel代码所需的栈，叫bootstack；第三部分是IO设备对应的物理地址，第
四部分包含了kernel的代码段、数据段和boot_alloc分配的空间。

### Part 2

pgdir_walk(): 参考xv6的page_walk()函数，但是加入了处理大页(large page的逻辑。

page_insert(): 要处理corner-case，即同一个物理页被重复插入页表的同一个地方(
映射到相同的虚拟地址)，不处理的话，会导致这个物理页被remove，加到freelist里面。对这种corner
-case做专门处理不太优雅，有个很tricky的方法是，将物理页的引用加1这一步骤放到remove 
page之前，这样物理页的引用先变成2，然后经过remove page后，又重新变成1，这样在remove 
page的时候，由于物理的的引用不为1，这个物理页也不会被加到freelist里面。


### Part 3

mem_init(): 由于在mem_init时被映射的虚拟地址都是在UTOP以上的，UTOP以上映射到的物理页是永远
不会被加到freelist的，UTOP以上的虚拟地址映射到物理页并不会增加物理页的引用数，所以在mem_ini
t中应该使用boot_map_region函数，而不是page_insert函数，因为前者只做映射，并不增加相应物理
页的引用数，而后者会增加。使用了大页映射之后，在lcr3之前需要将cr4的PSE位置上1。




## 第二部分 -- 问题的解答

1. Assuming that the following JOS kernel code is correct, what type should
variable x have, uintptr_t or physaddr_t?
    | mystery_t x;
    | char* value = return_a_pointer();
    | *value = 10;
    | x = (mystery_t) value;

解答：
uintptr_t, 因为代码里面出现的指针代表的虚拟地址，物理地址需要通过查页表并且和虚拟地址拼凑而成
或者将物理地址-KERNBASE得到。

2. What entries (rows) in the page directory have been filled in at this
point? What addresses do they map and where do they point? In other words,
fill out this table as much as possible:

解答(注意：使用了大页)：

Entry | Base Virtual Address |  Points to (logically):
1023  | 0xffc00000           | Page table for top 4MB of phys memory
.     | .                    | 没有映射
.     | .                    | 没有映射
960   | 0xf0000000           | 物理地址底4MB的页表
.     | .                    | 没有映射 
958   | 0xef800000           | kernel栈的页表(只有一部分是栈)
957   | 0xef400000           | 指向page directory table所在的物理地址
956   | 0xef000000           | pages数组
.     | .                    | 没有映射 
.     | .                    | 没有映射 
.     | .                    | 没有映射 
2     | 0x00800000           | 没有映射
1     | 0x00400000           | 没有映射
0     | 0x00000000           | 没有映射

3. (From Lecture 3) We have placed the kernel and user environment in the same
address space. Why will user programs not be able to read or write the 
kernel's memory? What specific mechanisms protect the kernel memory?

解答：
MMU在进行地址翻译的时候会进行权限检查。

有些内存是用户可读但不可以修改的，将这些内容在页表中对应的页表条目的PTE_U(用户/内核权限位)
置为1，而PTE_W置为0，这样用户可读不可写，而kernel可以无视PTE_W位来进行读写操作。

有些内存是用户不可访问的，将这些内容在页表中对应的页表条目的PTE_U置为0即可，这样就只有kernel
可以访问。

4. What is the maximum amount of physical memory that this operating system
can support? Why?

解答：jos中需要用struct page来记录物理页的使用情况，一个struct 
page代表一个物理页，在页表中，用UPAGES到UVPT的虚拟地址来映射到存放struct
page的物理地址，这段的大小是4MB，一个struct page的大小是8个byte，那么这段内存可以放下4M / 
8B = 512K个 struct page，由于每个page对应的物理页大小是4KB，所以512K个struct 
page可以表示512K * 4KB = 2G内存。

【注意】但是，实际上，由于struct page分配在物理内存上的位置是由boot_alloc来实现的。由于初始
页表只映射了4MB的内存，而且部分已经被内核的代码和数据段所使用，留给struct page的内存是不足4M
的，因此，虽然【逻辑上】可以支持2G物理内存，但是实际上最大支持的物理内存是不足2G的。

5. How much space overhead is there for managing memory, if we actually had 
the maximum amount of physical memory? How is this overhead broken down?

解答：
这里的以逻辑上最大支持2G内存为前提，并且采用两级页表的形式，那么最大的overhead(
有些二级页表即使没有全部用完，但是也需要一个4K页来做二级页表)为：
page directory table: 1 * 4KB = 4KB
page tables: 1024 * 4K = 4M
npages数组: 4M
合计：1028K


6. Revisit the page table setup in kern/entry.S and kern/entrypgdir.c. 
Immediately after we turn on paging, EIP is still a low number (a little over 
1MB). At what point do we transition to running at an EIP above KERNBASE? What 
makes it possible for us to continue executing at a low EIP between when we 
enable paging and when we begin running at an EIP above KERNBASE? Why is this 
transition necessary?

解答：
在entry.S中call i386_init之后EIP从低地址段变到了高地址段。

因为在entrypgdir.c中有个初始页表同时将0 - 4MB和KERNBASE - KERNBASE+4MB的虚拟地址映射到了0 - 4MB的物理地址。由于页表中有0 - 4MB的虚拟地址直接映射到
0 - 4MB的物理地址，在开启地址翻译模式前后，即当eip还是比较小的时候，是否采用地址翻译得到物理
地址都是一致的、连续的。由于kernel代码在链接的时候被链接到了高地址（KERNBASE之上），但是小部
分高的虚拟地址也同样被映射到了0 - 4MB的物理地址，所以在eip很大的时候，仍然能够继续执行。

由于代码中的指针、地址都是虚拟地址，kernel的代码的虚拟地址应该是在KERNBASE之上的，这个过程必
须在链接的时候进行，因此在运行kernel的代码来产生页表的时候，kernel代码就已经是虚拟地址了。为
了在创建好新页表之前能够正确执行kernel的代码，必须要用一个初始的默认页表，并且要将kernel的代
码映射好，在运行kernel代码之前就已经要切换到地址翻译模式。这个切换过程也是需要代码逻辑的，在
entry中，为了使entry的切换逻辑后面的代码（虚拟地址在0 - 4MB内）能够连续执行，默认页表也需要将 0 - 4MB的虚拟地址映射到0 - 4MB的物理地址上。




## 第三部分 -- challenge的设计

在此次lab中，我选择了第二个challenge，虽然第一个challenge我没有实现，但是思路是采用malloc
中对于堆的管理方法，使用显式空闲链表、推迟合并（要使用连续物理页的情况比较少）、最佳适配的设计
方法，下面讲解我实现第二个challenge的思路。

解答：

showmappings使用pgdir_walk来获得相应的pte，进而得到相应的物理地址，并显示相应的权限位，特
别要注意是区分大页和小页，跳过未被映射过的虚拟地址，还要注意对输入进行检查，比如输入是否非法和
低地址是否大于高地址。输出的格式如下:
K> showmappings 0x0 0xf0000000
0xef000000 ---> 0x00100000   P-U------
0xef7bc000 ---> 0x00100000   PWU------
0xefbf8000 ---> 0x00100000   PW-------
0xf0000000 ---> 0x00000000   PW---ADS-


setpermission也是需要进行输入检查，通过ptedir_walk获得pte的虚拟地址，根据输入的权限修改pt
e的权限位，但是页表中不存在的项，不进行任何修改。


memdump也是需要像showmappings一样，检查输出，主要大小页区别，不打印未被映射过的虚拟地址，采
用小端法将地址对应内容逐Byte打印出来。-v参数表示的是输入的是虚拟地址，而-p参数表示的是输入的是
物理地址。输出的格式如下:
K> memdump -v 0x0 0xef000100
ef000000: 00 00 00 00
ef000001: 00 00 00 00
ef000002: 00 00 00 00
ef000003: 00 00 00 00
ef000004: 00 00 00 00
ef000005: 00 00 00 f0
ef000006: 00 00 f0 a7
ef000007: 00 f0 a7 13
ef000008: f0 a7 13 f0
